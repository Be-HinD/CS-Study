## UDP

- User Datagram Protocol.
- 비연결지향. 연결된 상태에서 데이터를 전달하는게 아님 -> 신뢰성이 낮음 (순서 역전, 중복, 누락 등)
- 보안과 신뢰성보다 전송 속도와 효율성이 더 중요한 경우에 사용.
    - 시간에 민감한 애플리케이션에서 주로 사용. 실시간 시스템에서는 지연된 패킷을 기다리는 것보다 삭제 후 다음 실시간 데이터를 받아 처리하는게 더 바람직하기 때문.

![](Pasted%20image%2020240102093942.png)

- Port: 2bytes. ~65,535
- Length: Header + Payload

### UDP를 사용하는 프로그램

- DNS: 도메인 주소에 해당하는 IP 주소를 알려주는 프로그램(서비스)

---

## TCP

- Transmission Control Protocol.
- 연결 지향형. 안정적으로, 순서대로, 에러 없이 교환. 대신 UDP보다는 비교적 느림.
- 가장 일반적으로는 TCP-IPv4-Ethernet 사용.

![](Pasted%20image%2020240102095232.png)

- 일반적인 헤더 길이는 20bytes인데, 여기도 Option 수에 따라 최대 60bytes까지 증가 가능.
- Offset: 헤더 길이를 /4 한 값이 들어감.
- Window: 데이터를 얼마나 더 보낼 수 있는지(버퍼 가용 공간)를 상대방에게 알리기 위해 사용.
- Urgent Pointer: U Flag와 같이 사용. 어디서부터 중요한 데이터인지?
- TCP Flags: TCP의 주된 기능을 이 Flag를 사용해 표현. U, A, P, R, S, F는 기억해두는게 좋고, 그 중에서도 중요한건 A, R, S, F 정도.
    - Urgent: 지금 보내는 데이터가 우선순위가 높음. 위에서 말한 Urgent Pointer와 세트.
    - Ack: 연결 승인, 추가 전송 승인 등 승인 메시지를 보낼 때 사용.
    - Push: 일반적으로는 TCP 버퍼에 데이터가 일정 크기 이상 쌓여야 전송이 가능한데, 이 양에 상관 없이 패킷을 전송하는 것.
    - Reset: 초기화. 상대방과 연결이 된 상태에서 문제가 발생해서 연결 초기화(재수립).
    - Sync: 상대방과 연결을 시작할 때 동기화를 위해 사용하는 Flag. 서로 상태를 계속 주고받으며 동기화. 가장 중요.
    - Fin: 연결 종료.

### TCP 통신 과정

#### 연결 수립

- 프로세스간 연결을 위해 가장 먼저 수행되는 과정.

1. 클라이언트 -> 서버: 연결 요청 패킷 보냄. ![](Pasted%20image%2020240102103804.png)
    - Sync 플래그 세팅. Seq 번호, Ack 번호가 세팅되어 전송되는 것이 중요.
2. 서버 -> 클라이언트: 요청 수락 패킷 보냄. ![](Pasted%20image%2020240102104013.png)
    - Sync, Ack Flag가 같이 세팅된 패킷을 보냄.
3. 클라이언트 -> 서버: 이를 최종 수락 패킷 전송. ![](Pasted%20image%2020240102104101.png)
    - 대답만 하면 되므로 Ack Flag만 세팅.

- 3단계로 이루어져 있어서 3-way handshake라고 함.

#### 데이터 송수신 과정

![](Pasted%20image%2020240102105807.png)

- 보낸 쪽에서 또 보낼 때는 Seq, Ack 번호 그대로 사용.
- 받는 쪽에서
    - Seq 번호는 받은 Ack 번호 그대로 사용.
    - Ack 번호는 받은 Seq 번호 + 데이터 크기.
        - 위 그림에서는 첫 번째에 클라이언트가 서버로 100바이트 데이터를 전송했기 때문에 서버의 Ack 번호는 101 + 100 = 201.
- Window 버퍼에 충분히 데이터가 안 찼더라도 패킷을 보내기 위해 Push flag 세팅.
- 클라이언트가 원하는 데이터를 받았다면 잘 받았다고 Ack 메시지 전송.

#### TCP 상태 전이도

![](Pasted%20image%2020240102111449.png)

- 실선은 클라이언트의 상태 변화, 점선은 서버의 상태 변화.
- 이 중 중요한 상태 두 개는 LISTEN, ESTABLISHED.
    - LISTEN: 서버가 포트를 열어두고 클라이언트 요청이 있는지 듣고 있는 상태.
    - ESTABLISHED: 연결이 수립된 상태. 이 때부터 데이터 송수신 가능.
    - CLOSED: 서버 포트가 닫혀있는 상태.
    - SYN_SENT: 클라이언트가 SYN 플래그를 포함하는 연결 요청을 보내서 active open하는 상태.
    - SYN_RCVD: 클라이언트 연결 요청을 받은 상태. 클라이언트에 ACK 패킷 보냄.

---

## TCP 송수신 원리

- 소켓 통신이니 파일을 대상으로 하는데, RWX에서 X는 없고, Read = Receive, Write = Send.
- 일반적으로는 Buffered I/O 방식으로 동작. 파일에서 읽어올 때 쓰는 버퍼가 있고, 소켓에 쓸 때 사용하는 버퍼도 있음.
- IP로 내려갈 때 Segmentation 됨.
    - 각 Segment(L4의 PDU)에 연속적인 번호를 할당하여 패킷 순서 구분.
- 패킷의 목적지가 어디인가?
    - Packet은 논리적으로 Endpoint 사이에서 통신하지만, Frame(L2의 PDU)의 목적지는 매 번 (다음 스위치 또는 라우터 등으로) 바뀔 수 있음.
- 서버는 세그먼트를 2개 보내고는 연속해서 보내는게 아니라 Wait을 함.
    - 클라이언트는 세그먼트를 2개 이상 받았다면 TCP 쪽에서 서버에게 잘 받았다고 ACK#3을 보냄.
    - 서버는 이 ACK을 받은 다음에 3번 세그먼트를 전송.
    - 이것때문에 **속도 지연이 발생**. TCP가 UDP보다 느린 이유.
- TCP 버퍼를 Window라고 함. 이 크기는 정해져있음.
    - 클라이언트는 ACK#N을 보낼 때 가용 window 크기도 보냄.
    - **서버에서 이 가용 공간이 부족(Window Size < MSS)하다고 판단하면 다음 세그먼트를 전송하지 않음(Wait).**
    - 클라이언트의 Read 속도가 네트워크 수신 속도보다 느리다면 버퍼 flush를 못하고 계속 쌓임. 그러면 서버가 더 보내지 못해서 더 느려짐.
        - 만약 Net I/O 속도가 느린 것 같다? 일단 프로그램의 Read 속도에 문제가 없는지부터 확인을 하자. TCP 통신에서는 송신보다 수신쪽에 문제가 있는 경우가 생각보다 많음.

---

> 사진 캡처 출처
> - [따라하면서 배우는 IT. "08. 비연결지향형 UDP 프로토콜 - 이론" (5'06")](https://youtu.be/3MkI3FBFzX8?feature=shared)
> - [따라하면서 배우는 IT. "09. 연결지향형 TCP 프로토콜 - TCP 프로토콜 구조와 TCP의 플래그" (11'36")](https://youtu.be/cOK_f9_k_O0?feature=shared)
> - [따라하면서 배우는 IT. "09. 연결지향형 TCP 프로토콜 - TCP 3Way Handshake" (14'13")](https://youtu.be/Ah4-MWISel8?feature=shared)
> - [따라하면서 배우는 IT. "09. 연결지향형 TCP 프로토콜 - TCP를 이용한 데이터 전송 과정" (5'38")](https://youtu.be/0vBR666GZ5o?feature=shared)
> - [따라하면서 배우는 IT. "09. 연결지향형 TCP 프로토콜 - TCP의 연결 상태 변화" (6'27")](https://youtu.be/yY0uQf0BTH8?feature=shared)
> - [널널한 개발자 TV. "이해하면 인생이 바뀌는 TCP 송/수신 원리" (32'19")](https://youtu.be/K9L9YZhEjC0?feature=shared)
